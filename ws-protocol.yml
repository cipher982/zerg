# WebSocket Protocol Schema v1
# Single source of truth for all WebSocket message types and structures
# This file generates both Rust and Python types to eliminate transformation layers

$schema: "http://json-schema.org/draft-07/schema#"
$id: "ws-protocol-v1"

definitions:
  # Core envelope structure - all messages use this format
  Envelope:
    type: object
    required: [v, type, topic, ts, data]
    additionalProperties: false
    properties:
      v: 
        type: integer
        const: 1
        description: "Protocol version"
      type:
        type: string
        description: "Message type identifier"
      topic:
        type: string
        description: "Topic routing string (e.g., 'agent:123', 'thread:456')"
      req_id:
        type: string
        description: "Optional request correlation ID"
      ts:
        type: integer
        description: "Timestamp in milliseconds since epoch"
      data:
        type: object
        description: "Message payload - structure depends on type"

  # Base structures for common fields
  AgentRef:
    type: object
    required: [id]
    properties:
      id: { type: integer, minimum: 1 }
      
  ThreadRef:
    type: object
    required: [thread_id]
    properties:
      thread_id: { type: integer, minimum: 1 }
      
  UserRef:
    type: object
    required: [id]
    properties:
      id: { type: integer, minimum: 1 }

  ExecutionRef:
    type: object
    required: [execution_id]
    properties:
      execution_id: { type: integer, minimum: 1 }

  # Message payload schemas
  RunUpdateData:
    type: object
    required: [id, agent_id, status]
    properties:
      id: { type: integer, minimum: 1 }
      agent_id: { type: integer, minimum: 1 }
      thread_id: { type: integer, minimum: 1 }
      status: 
        type: string
        enum: [queued, running, success, failed]
      trigger:
        type: string
        enum: [manual, schedule, api]
      started_at: { type: string, format: date-time }
      finished_at: { type: string, format: date-time }
      duration_ms: { type: integer, minimum: 0 }
      error: { type: string }

  AgentEventData:
    type: object
    required: [id]
    properties:
      id: { type: integer, minimum: 1 }
      status: { type: string }
      last_run_at: { type: string, format: date-time }
      next_run_at: { type: string, format: date-time }
      last_error: { type: string }
      name: { type: string }
      description: { type: string }

  ThreadEventData:
    type: object
    required: [thread_id]
    properties:
      thread_id: { type: integer, minimum: 1 }
      agent_id: { type: integer, minimum: 1 }
      title: { type: string }
      created_at: { type: string, format: date-time }
      updated_at: { type: string, format: date-time }

  ThreadMessageData:
    type: object
    required: [thread_id, message]
    properties:
      thread_id: { type: integer, minimum: 1 }
      message:
        type: object
        required: [id, role, content]
        properties:
          id: { type: integer, minimum: 1 }
          role: 
            type: string
            enum: [user, assistant, system, tool]
          content: { type: string }
          metadata: { type: object }
          created_at: { type: string, format: date-time }

  StreamStartData:
    type: object
    required: [thread_id]
    properties:
      thread_id: { type: integer, minimum: 1 }

  StreamChunkData:
    type: object
    required: [thread_id, chunk_type]
    properties:
      thread_id: { type: integer, minimum: 1 }
      chunk_type:
        type: string
        enum: [assistant_token, assistant_message, tool_output]
      content: { type: string }
      tool_name: { type: string }
      tool_call_id: { type: string }

  StreamEndData:
    type: object
    required: [thread_id]
    properties:
      thread_id: { type: integer, minimum: 1 }

  AssistantIdData:
    type: object
    required: [thread_id, message_id]
    properties:
      thread_id: { type: integer, minimum: 1 }
      message_id: { type: integer, minimum: 1 }

  UserUpdateData:
    type: object
    required: [id]
    properties:
      id: { type: integer, minimum: 1 }
      email: { type: string, format: email }
      display_name: { type: string }
      avatar_url: { type: string, format: uri }

  NodeStateData:
    type: object
    required: [execution_id, node_id, status]
    properties:
      execution_id: { type: integer, minimum: 1 }
      node_id: { type: string, minLength: 1 }
      status:
        type: string
        enum: [running, success, failed]
      output: { type: object }
      error: { type: string }

  ExecutionFinishedData:
    type: object
    required: [execution_id, status]
    properties:
      execution_id: { type: integer, minimum: 1 }
      status:
        type: string
        enum: [success, failed]
      error: { type: string }
      duration_ms: { type: integer, minimum: 0 }

  NodeLogData:
    type: object
    required: [execution_id, node_id, stream, text]
    properties:
      execution_id: { type: integer, minimum: 1 }
      node_id: { type: string, minLength: 1 }
      stream:
        type: string
        enum: [stdout, stderr]
      text: { type: string }

  SubscribeData:
    type: object
    required: [topics]
    properties:
      topics:
        type: array
        items: { type: string }
        minItems: 1
      message_id: { type: string }

  UnsubscribeData:
    type: object
    required: [topics]
    properties:
      topics:
        type: array
        items: { type: string }
        minItems: 1
      message_id: { type: string }

  SendMessageData:
    type: object
    required: [thread_id, content]
    properties:
      thread_id: { type: integer, minimum: 1 }
      content: { type: string, minLength: 1 }
      metadata: { type: object }

  PingData:
    type: object
    properties:
      timestamp: { type: integer }

  PongData:
    type: object
    properties:
      timestamp: { type: integer }

  ErrorData:
    type: object
    required: [error]
    properties:
      error: { type: string, minLength: 1 }
      details: { type: object }

# Message type definitions with payload schemas and routing
messages:
  # Connection & Control
  ping:
    payload: { $ref: "#/definitions/PingData" }
    topic_pattern: "system"
    direction: [client_to_server, server_to_client]
    
  pong:
    payload: { $ref: "#/definitions/PongData" }
    topic_pattern: "system"
    direction: [client_to_server, server_to_client]
    
  error:
    payload: { $ref: "#/definitions/ErrorData" }
    topic_pattern: "system"
    direction: [server_to_client]
    handler_method: handle_error

  # Subscription Management
  subscribe:
    payload: { $ref: "#/definitions/SubscribeData" }
    topic_pattern: "system"
    direction: [client_to_server]
    
  unsubscribe:
    payload: { $ref: "#/definitions/UnsubscribeData" }
    topic_pattern: "system"
    direction: [client_to_server]

  # Thread Messages
  send_message:
    payload: { $ref: "#/definitions/SendMessageData" }
    topic_pattern: "thread:{thread_id}"
    direction: [client_to_server]
    
  thread_message:
    aliases: [thread_message_created]
    payload: { $ref: "#/definitions/ThreadMessageData" }
    topic_pattern: "thread:{thread_id}"
    direction: [server_to_client]
    handler_method: handle_thread_message

  # Streaming
  stream_start:
    payload: { $ref: "#/definitions/StreamStartData" }
    topic_pattern: "thread:{thread_id}"
    direction: [server_to_client]
    handler_method: handle_stream_start
    
  stream_chunk:
    payload: { $ref: "#/definitions/StreamChunkData" }
    topic_pattern: "thread:{thread_id}"
    direction: [server_to_client]
    handler_method: handle_stream_chunk
    
  stream_end:
    payload: { $ref: "#/definitions/StreamEndData" }
    topic_pattern: "thread:{thread_id}"
    direction: [server_to_client]
    handler_method: handle_stream_end
    
  assistant_id:
    payload: { $ref: "#/definitions/AssistantIdData" }
    topic_pattern: "thread:{thread_id}"
    direction: [server_to_client]
    handler_method: handle_assistant_id

  # Agent Events
  agent_event:
    aliases: [agent_created, agent_updated, agent_deleted, agent_state]
    payload: { $ref: "#/definitions/AgentEventData" }
    topic_pattern: "agent:{id}"
    direction: [server_to_client]
    handler_method: handle_agent_event

  # Thread Events  
  thread_event:
    aliases: [thread_created, thread_updated, thread_deleted]
    payload: { $ref: "#/definitions/ThreadEventData" }
    topic_pattern: "thread:{thread_id}"
    direction: [server_to_client]
    handler_method: handle_thread_event

  # Run Updates
  run_update:
    payload: { $ref: "#/definitions/RunUpdateData" }
    topic_pattern: "agent:{agent_id}"
    direction: [server_to_client]
    handler_method: handle_run_update

  # User Updates
  user_update:
    payload: { $ref: "#/definitions/UserUpdateData" }
    topic_pattern: "user:{id}"
    direction: [server_to_client]
    handler_method: handle_user_update

  # Workflow Execution
  node_state:
    payload: { $ref: "#/definitions/NodeStateData" }
    topic_pattern: "workflow_execution:{execution_id}"
    direction: [server_to_client]
    handler_method: handle_node_state
    
  execution_finished:
    payload: { $ref: "#/definitions/ExecutionFinishedData" }
    topic_pattern: "workflow_execution:{execution_id}"
    direction: [server_to_client]
    handler_method: handle_execution_finished
    
  node_log:
    payload: { $ref: "#/definitions/NodeLogData" }
    topic_pattern: "workflow_execution:{execution_id}"
    direction: [server_to_client]
    handler_method: handle_node_log

# Topic routing patterns
topics:
  agent: 
    pattern: "agent:{id}"
    description: "Agent lifecycle events and run updates"
    
  thread:
    pattern: "thread:{thread_id}" 
    description: "Thread messages, streaming, and lifecycle events"
    
  user:
    pattern: "user:{id}"
    description: "User profile updates"
    
  workflow_execution:
    pattern: "workflow_execution:{execution_id}"
    description: "Workflow execution state and logs"
    
  system:
    pattern: "system"
    description: "Control messages, errors, and system announcements"

# Handler interface definitions for generated routing
handlers:
  dashboard:
    description: "Handles agent management, runs, and workflow execution events"
    handles:
      - run_update
      - agent_event
      - execution_finished
      - node_state
      - node_log
    topics:
      - "agent:*"
      - "workflow_execution:*"
      
  chat:
    description: "Handles thread messages and streaming events"
    handles:
      - thread_message
      - stream_start
      - stream_chunk
      - stream_end
      - assistant_id
    topics:
      - "thread:*"

# Message-to-handler mappings (for validation and routing generation)
message_routing:
  dashboard_messages:
    - run_update
    - agent_event  # includes aliases: agent_created, agent_updated, agent_deleted, agent_state
    - execution_finished
    - node_state
    - node_log
    
  chat_messages:
    - thread_message  # includes aliases: thread_message_created
    - stream_start
    - stream_chunk
    - stream_end
    - assistant_id
    
  # Messages that can be handled by multiple handlers or are system-wide
  shared_messages:
    - thread_event  # includes aliases: thread_created, thread_updated, thread_deleted
    - user_update
    - ping
    - pong
    - error

# Validation rules for schema completeness
validation:
  rules:
    - "Every server_to_client message must have a handler_method"
    - "All handler_method names must be unique within a handler group"
    - "All messages listed in handlers.*.handles must exist in the messages section"
    - "All message aliases must resolve to the same handler_method as the primary message"
    - "Handler topic patterns must match message topic_patterns"
  
  required_for_generation:
    - "handler_method field on all server_to_client messages"
    - "handlers section with complete method mappings"
    - "message_routing section for validation"

# Protocol versioning
version:
  current: 1
  compatibility:
    - version: 1
      supported: true
      required_fields: [v, type, topic, ts, data]