# Unified Docker Compose - All services in one network
# Use: docker-compose -f docker/docker-compose.unified.yml up
#
# REQUIRED: Configure all ports via environment variables:
#   - JARPXY_PORT - Jarvis + Zerg entry point (e.g., 30080)
#   - JARVIS_WEB_PORT - Internal web port (e.g., 8080)
#   - JARVIS_SERVER_PORT - Internal server port (e.g., 8787)
#   - ZERG_BACKEND_PORT - Internal backend port (e.g., 8000)
#   - ZERG_FRONTEND_PORT - Internal frontend port (e.g., 5173)
#
# Example: JARPXY_PORT=30080 docker-compose -f docker/docker-compose.unified.yml up

x-common-variables: &common-variables
  # Required ports - FAIL FAST if not set
  JARVIS_WEB_PORT: ${JARVIS_WEB_PORT}
  JARVIS_SERVER_PORT: ${JARVIS_SERVER_PORT}
  ZERG_BACKEND_PORT: ${ZERG_BACKEND_PORT}
  ZERG_FRONTEND_PORT: ${ZERG_FRONTEND_PORT}
  JARPXY_PORT: ${JARPXY_PORT}

services:
  # PostgreSQL Database
  postgres:
    image: postgres:16-alpine
    restart: unless-stopped
    environment:
      POSTGRES_DB: ${POSTGRES_DB}
      POSTGRES_USER: ${POSTGRES_USER}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
    volumes:
      - ../logs/postgres:/var/log/postgresql
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER} -d ${POSTGRES_DB}"]
      interval: 5s
      timeout: 3s
      retries: 5
    networks:
      - swarm-network

  # Zerg Backend API
  zerg-backend:
    build:
      context: ../apps/zerg/backend
      dockerfile: ../../../docker/backend.dockerfile
      target: development
      args:
        BUILD_ENV: development
    restart: unless-stopped
    depends_on:
      postgres:
        condition: service_healthy
    environment:
      <<: *common-variables
      ENVIRONMENT: development
      DATABASE_URL: postgresql://${POSTGRES_USER}:${POSTGRES_PASSWORD}@postgres:5432/${POSTGRES_DB}
      JWT_SECRET: ${JWT_SECRET:-dev_jwt_secret_change_in_production}
      # Do not bake secrets into compose defaults; require env or use a clearly non-secret dev placeholder
      FERNET_SECRET: ${FERNET_SECRET:-dev_fernet_secret_32_chars_long!}
      TRIGGER_SIGNING_SECRET: ${TRIGGER_SIGNING_SECRET:-dev_trigger_secret}
      AUTH_DISABLED: ${AUTH_DISABLED:-1}
      GOOGLE_CLIENT_ID: ${GOOGLE_CLIENT_ID}
      GOOGLE_CLIENT_SECRET: ${GOOGLE_CLIENT_SECRET}
      GITHUB_CLIENT_ID: ${GITHUB_CLIENT_ID}
      GITHUB_CLIENT_SECRET: ${GITHUB_CLIENT_SECRET}
      OPENAI_API_KEY: ${OPENAI_API_KEY}
      JARVIS_DEVICE_SECRET: ${JARVIS_DEVICE_SECRET:-test-secret-for-integration-testing}
      ALLOWED_CORS_ORIGINS: "*"
      LLM_TOKEN_STREAM: ${LLM_TOKEN_STREAM:-true}
      DEV_ADMIN: ${DEV_ADMIN:-1}
      SWARMLET_DATA_PATH: /app/data/workers
      RELOAD: true
      DEBUG: true
      LOG_LEVEL: DEBUG
    # Internal only - accessed via reverse proxy
    ports: []
    volumes:
      - ../apps/zerg/backend:/app:cached
      - backend_dev_static:/app/static
      - ../data:/app/data
      - /Users/davidrose/.ssh:/home/zerg/.ssh:ro
      - ../logs/backend:/app/logs
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:${ZERG_BACKEND_PORT}/health"]
      interval: 10s
      timeout: 5s
      retries: 3
      start_period: 30s
    networks:
      - swarm-network

  # Zerg Frontend (React Dashboard)
  zerg-frontend:
    build:
      context: ../apps/zerg/frontend-web
      dockerfile: Dockerfile
      target: development
    restart: unless-stopped
    depends_on:
      - zerg-backend
    environment:
      <<: *common-variables
      # Use absolute URLs for dev - Vite behind nginx proxy has issues with relative URLs
      VITE_API_BASE_URL: http://localhost:${JARPXY_PORT}/api
      VITE_WS_BASE_URL: ws://localhost:${JARPXY_PORT}
      # Disable frontend auth guard in development (matches AUTH_DISABLED=1 on backend)
      VITE_AUTH_ENABLED: "false"
    # Internal only - accessed via reverse proxy
    ports: []
    volumes:
      - ../apps/zerg/frontend-web:/app:cached
      - /app/node_modules
      - ../logs/frontend:/app/logs
    healthcheck:
      test: ["CMD", "wget", "--no-verbose", "--tries=1", "--spider", "http://127.0.0.1:${ZERG_FRONTEND_PORT}/"]
      interval: 15s
      timeout: 5s
      retries: 3
      start_period: 45s
    networks:
      - swarm-network

  # Jarvis Web UI (PWA)
  jarvis-web:
    build:
      context: ..
      dockerfile: apps/jarvis/apps/web/Dockerfile
    restart: unless-stopped
    environment:
      <<: *common-variables
      VITE_ZERG_API_URL: /api
      VITE_JARVIS_DEVICE_SECRET: ${JARVIS_DEVICE_SECRET:-test-secret}
      VITE_OPENAI_API_KEY: ${OPENAI_API_KEY}
      VITE_VOICE_CONTEXT: "personal"
      # HMR needs to know the external proxy port for WebSocket connection
      JARPXY_PORT: ${JARPXY_PORT}
    # Internal only - accessed via reverse proxy
    ports: []
    volumes:
      - ../apps/jarvis/apps/web:/app/apps/jarvis/apps/web:cached
      - ../apps/jarvis/configs:/app/apps/jarvis/configs:cached
      - ../apps/jarvis/packages:/app/apps/jarvis/packages:cached
      - /app/node_modules
      - ../logs/jarvis-web:/app/logs
    healthcheck:
      test: ["CMD", "wget", "--no-verbose", "--tries=1", "--spider", "http://127.0.0.1:${JARVIS_WEB_PORT}/"]
      interval: 15s
      timeout: 5s
      retries: 3
      start_period: 30s
    networks:
      - swarm-network

  # Jarvis Server (OpenAI bridge + MCP tools)
  jarvis-server:
    build:
      context: ..
      dockerfile: apps/jarvis/apps/server/Dockerfile
    restart: unless-stopped
    environment:
      <<: *common-variables
      # Set PORT for server.js (uses process.env.PORT)
      PORT: ${JARVIS_SERVER_PORT}
      # OpenAI API key is optional - server will warn if missing
      OPENAI_API_KEY: ${OPENAI_API_KEY}
      SKIP_MCP: ${SKIP_MCP:-1}
    # Internal only - accessed via reverse proxy
    ports: []
    volumes:
      - ../apps/jarvis/apps/server:/app/apps/server:cached
      - ../apps/jarvis/configs:/app/configs:cached
      - ../apps/jarvis/packages:/app/packages:cached
      - ../logs/jarvis-server:/app/logs
    networks:
      - swarm-network
    healthcheck:
      test: ["CMD-SHELL", "wget --no-verbose --tries=1 --spider http://127.0.0.1:${JARVIS_SERVER_PORT}/session"]
      interval: 15s
      timeout: 5s
      retries: 3
      start_period: 10s

  # Reverse Proxy - Single entry point to all services
  reverse-proxy:
    image: nginx:alpine
    restart: unless-stopped
    stop_grace_period: 1s
    environment:
      <<: *common-variables
    ports:
      # Single entry point - path-based routing
      - "${JARPXY_PORT}:80"
      # Legacy port 81 removed (path-based routing only)
    volumes:
      - ./nginx/docker-compose.unified.conf:/etc/nginx/conf.d/default.conf:ro
      - ../logs/nginx:/var/log/nginx
    depends_on:
      - jarvis-web
      - jarvis-server
      - zerg-frontend
      - zerg-backend
    healthcheck:
      test: ["CMD", "wget", "--no-verbose", "--tries=1", "--spider", "http://127.0.0.1/health"]
      interval: 15s
      timeout: 5s
      retries: 3
    networks:
      - swarm-network

networks:
  swarm-network:
    driver: bridge

volumes:
  backend_dev_static:
    driver: local
