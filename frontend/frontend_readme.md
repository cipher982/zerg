# AI Agent Platform – Frontend Overview

Welcome to the Rust + WebAssembly frontend of the AI Agent Platform!  
This README describes:  
1. How the frontend is architected (state management, messages, UI layering).  
2. Where to find specific functionality (Canvas, Chat, Dashboard).  
3. How to build, run, and contribute.

--------------------------------------------------------------------------------
## Table of Contents
1. Introduction and High-Level Flow  
2. Project Structure  
3. State Management (Elm-Style)  
4. Network Layer  
5. Major UI Components (Dashboard, Canvas, Chat)  
6. Commands and Side Effects  
7. Tips for Contributing

--------------------------------------------------------------------------------
## 1) Introduction and High-Level Flow

This frontend is compiled from Rust → WebAssembly. It uses an “Elm-like” architecture in which:  
• User actions or system events produce a Message (see src/messages.rs).  
• These go through an update function (src/update.rs) that updates AppState and emits Commands for side effects (HTTP calls, WebSocket actions, etc.).  
• The global AppState (src/state.rs) is a single “source of truth” containing:  
  – A list of Agents, Threads, Canvas Nodes, etc.  
  – The user’s current View (Dashboard, Canvas, or Chat).  
  – Current WebSocket connections / topic subscriptions.  

Under the hood, “command executors” run any side effects (e.g., fetch data from the backend API). Once the side effects resolve, they often dispatch new Messages, continuing the cycle.

--------------------------------------------------------------------------------
## 2) Project Structure

Below is a rough breakdown of critical directories and files:

• src/  
  ├── canvas/  
  │    ├── shapes.rs           (drawing shapes like rectangles, arrows on Canvas)  
  │    └── renderer.rs         (canvas rendering logic)  
  ├── components/  
  │    ├── dashboard/          (dashboard UI for listing agents)  
  │    ├── chat/               (chat UI logic, WebSocket manager)  
  │    └── canvas_editor.rs    (sets up the HTML Canvas + event listeners)  
  ├── network/  
  │    ├── api_client.rs       (handles HTTP API calls)  
  │    ├── ws_client_v2.rs     (WebSocket client code)  
  │    ├── topic_manager.rs    (subscribes/unsubscribes to WS topics)  
  │    └── messages.rs         (structures for WS messages)  
  ├── state.rs                 (global AppState, user selections, current view)  
  ├── messages.rs              (all possible front-end events, i.e. “Messages”)  
  ├── update.rs                (the “reducer”: transforms Messages → new state)  
  ├── command_executors.rs     (logic for executing side-effectful Commands)  
  ├── models.rs                (main data structures: agents, threads, nodes)  
  ├── storage.rs               (localStorage + saving/loading from backend)  
  ├── views.rs                 (functions to render specific views)  
  ├── lib.rs                   (WASM entry point [#[wasm_bindgen(start)]])  

• www/  
  ├── index.html               (core HTML page loading our WASM + JS)  
  ├── styles.css, chat.css     (styling)  
  └── index.js                 (generated by wasm-pack, references the WASM)

--------------------------------------------------------------------------------
## 3) State Management (Elm-Style)

We follow a unidirectional data flow:

1. The global state is in AppState (src/state.rs).  
   – This includes structured data like:  
     • agents (HashMap<u32, ApiAgent>)  
     • thread_messages, nodes, workflows, etc.  
   – Also includes ephemeral info like “current_thread_id” or “dragging = Some(node_id).”

2. Messages enumeration (src/messages.rs)  
   – Example: ToggleView(ActiveView), CreateAgent, LoadThreads, SendThreadMessage.  
   – These represent every possible user action or system event that can mutate the AppState.

3. The update function (src/update.rs)  
   – A big match on Message. We adjust state accordingly (e.g., add a node, change a thread’s title).  
   – Returns zero or more Command objects (HTTP request, WebSocket subscription, etc.).

4. Commands and command_executors  
   – Each Command is a structured “side effect” that update.rs cannot run directly (since it’s meant to be pure).  
   – Commands get passed to command_executors.rs, which actually performs the network calls or dispatches new messages after success/failure.

--------------------------------------------------------------------------------
## 4) Network Layer

All networking lives in src/network/:  
• api_client.rs → Basic HTTP fetch calls to the python backend (like “/api/agents”).  
• ws_client_v2.rs → Our actual WebSocket client that handles connect/disconnect + message parsing.  
• topic_manager.rs → Subscribes/unsubscribes to “topics” (like thread:123), distributing incoming WS messages to the correct handler in the code.  

When the frontend loads, lib.rs calls ws_client.connect() to open the socket. Once connected, it might subscribe to relevant topics (agent:*, thread:*) via the TopicManager.  

--------------------------------------------------------------------------------
## 5) Major UI Components

We have three primary “views,” each with distinct responsibilities:

1. Dashboard (src/components/dashboard)  
   – Displays a table of Agents with actions like “Edit, Chat, Create Agent.”  
   – Has an associated “ws_manager.rs” that subscribes to agent:* updates.  

2. Canvas (src/components/canvas_editor.rs + src/canvas/)  
   – A 2D area where “nodes” can be displayed and moved around (like agent nodes, user input nodes).  
   – renderer.rs draws the shapes. canvas_editor.rs sets up event handlers (mouse, drag, zoom).  

3. Chat (src/components/chat/)  
   – ChatView is built from chat_view.rs + ws_manager.rs.  
   – There’s a side panel with threads, plus the conversation area. Real-time updates come via the WebSocket “thread:*” subscription.

The active view is always stored in AppState.active_view. Switching tabs triggers a ToggleView(Message) → update, and we hide all other view containers in the DOM.

--------------------------------------------------------------------------------
## 6) Commands and Side Effects

After an update function handles a message (like “SendThreadMessage”), it might return:

  Command::SendThreadMessage { thread_id, content, client_id }

That goes to command_executors.rs, which does:  
• Actually calls the HTTP endpoint or run_thread.  
• On success/failure, dispatches more messages (e.g., ThreadMessageSent or ThreadMessageFailed).

This keeps update.rs “pure” while making side effects explicit and testable.