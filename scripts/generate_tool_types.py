#!/usr/bin/env python3
"""Generate Rust and Python types from tool schema."""

import yaml
import sys
from pathlib import Path
import json

def generate_rust_enums(schema_data):
    """Generate Rust enum definitions from tool schema."""
    
    tool_names = schema_data['components']['schemas']['ToolName']['enum']
    server_names = schema_data['components']['schemas']['ServerName']['enum']
    tool_mappings = schema_data['components']['schemas']['ToolRegistry']['properties']['tool_mappings']['properties']
    
    rust_code = """// Generated by generate_tool_types.py - DO NOT EDIT MANUALLY

use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub enum ToolName {
"""
    
    # Generate ToolName enum variants
    for tool in tool_names:
        variant_name = ''.join(word.capitalize() for word in tool.split('_'))
        rust_code += f"    {variant_name},\n"
    
    rust_code += """
}

impl ToolName {
    pub fn as_str(&self) -> &'static str {
        match self {
"""
    
    # Generate as_str implementation
    for tool in tool_names:
        variant_name = ''.join(word.capitalize() for word in tool.split('_'))
        rust_code += f'            Self::{variant_name} => "{tool}",\n'
    
    rust_code += """        }
    }
    
    pub fn from_str(s: &str) -> Option<Self> {
        match s {
"""
    
    # Generate from_str implementation
    for tool in tool_names:
        variant_name = ''.join(word.capitalize() for word in tool.split('_'))
        rust_code += f'            "{tool}" => Some(Self::{variant_name}),\n'
    
    rust_code += """            _ => None,
        }
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub enum ServerName {
"""
    
    # Generate ServerName enum variants
    for server in server_names:
        variant_name = server.capitalize()
        rust_code += f"    {variant_name},\n"
    
    rust_code += """
}

impl ServerName {
    pub fn as_str(&self) -> &'static str {
        match self {
"""
    
    # Generate ServerName as_str implementation
    for server in server_names:
        variant_name = server.capitalize()
        rust_code += f'            Self::{variant_name} => "{server}",\n'
    
    rust_code += """        }
    }
    
    pub fn from_str(s: &str) -> Option<Self> {
        match s {
"""
    
    # Generate ServerName from_str implementation
    for server in server_names:
        variant_name = server.capitalize()
        rust_code += f'            "{server}" => Some(Self::{variant_name}),\n'
    
    rust_code += """            _ => None,
        }
    }
}

/// Compile-time validated tool-to-server mapping
impl ToolName {
    pub fn server_name(&self) -> ServerName {
        match self {
"""
    
    # Generate tool-to-server mapping
    for tool_name, server_name_val in tool_mappings.items():
        tool_variant = ''.join(word.capitalize() for word in tool_name.split('_'))
        server_variant = server_name_val['const'].capitalize()
        rust_code += f"            Self::{tool_variant} => ServerName::{server_variant},\n"
    
    rust_code += """        }
    }
}

/// Validation functions for runtime checks
pub mod validation {
    use super::*;
    
    /// Validate that a tool name string matches a known tool
    pub fn validate_tool_name(name: &str) -> bool {
        matches!(name, "http_request" | "math_eval" | "get_current_time" | "datetime_diff" | "generate_uuid")
    }
    
    /// Validate that a server name string matches a known server
    pub fn validate_server_name(name: &str) -> bool {
        matches!(name, "http" | "math" | "datetime" | "uuid")
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_tool_name_roundtrip() {
        for tool in [
            ToolName::HttpRequest,
            ToolName::HttpGet,
            ToolName::MathEval,
            ToolName::GetCurrentTime,
            ToolName::DatetimeDiff,
            ToolName::GenerateUuid,
        ] {
            let s = tool.as_str();
            assert_eq!(ToolName::from_str(s), Some(tool));
        }
    }
    
    #[test]
    fn test_server_name_roundtrip() {
        for server in [ServerName::Http, ServerName::Math, ServerName::Datetime, ServerName::Uuid] {
            let s = server.as_str();
            assert_eq!(ServerName::from_str(s), Some(server));
        }
    }
    
    #[test]
    fn test_tool_server_mapping() {
        assert_eq!(ToolName::HttpRequest.server_name(), ServerName::Http);
        assert_eq!(ToolName::HttpGet.server_name(), ServerName::Http);
        assert_eq!(ToolName::MathEval.server_name(), ServerName::Math);
        assert_eq!(ToolName::GetCurrentTime.server_name(), ServerName::Datetime);
        assert_eq!(ToolName::DatetimeDiff.server_name(), ServerName::Datetime);
        assert_eq!(ToolName::GenerateUuid.server_name(), ServerName::Uuid);
    }
}
"""
    
    return rust_code

def generate_python_types(schema_data):
    """Generate Python dataclasses from tool schema."""
    
    tool_names = schema_data['components']['schemas']['ToolName']['enum']
    server_names = schema_data['components']['schemas']['ServerName']['enum']
    
    python_code = """# Generated by generate_tool_types.py - DO NOT EDIT MANUALLY

from enum import Enum
from typing import Dict
from typing import List
from typing import Optional


class ToolName(str, Enum):
    \"\"\"Built-in tool names available in the registry.\"\"\"

"""
    
    # Generate ToolName enum
    for tool in tool_names:
        constant_name = tool.upper()
        python_code += f'    {constant_name} = "{tool}"\n'
    
    python_code += """

class ServerName(str, Enum):
    \"\"\"Server/module names for tools.\"\"\"

"""
    
    # Generate ServerName enum
    for server in server_names:
        constant_name = server.upper()
        python_code += f'    {constant_name} = "{server}"\n'
    
    python_code += """

# Tool to server mapping for validation
TOOL_SERVER_MAPPING: Dict[ToolName, ServerName] = {
"""
    
    # Generate mapping
    tool_mappings = schema_data['components']['schemas']['ToolRegistry']['properties']['tool_mappings']['properties']
    for tool_name, server_info in tool_mappings.items():
        tool_const = tool_name.upper()
        server_const = server_info['const'].upper()
        python_code += f"    ToolName.{tool_const}: ServerName.{server_const},\n"
    
    python_code += """}


def validate_tool_registration(tool_name: str, server_name: str) -> bool:
    \"\"\"Validate that tool-server pairing matches schema.\"\"\"
    try:
        tool_enum = ToolName(tool_name)
        server_enum = ServerName(server_name)
        return TOOL_SERVER_MAPPING.get(tool_enum) == server_enum
    except ValueError:
        return False


def get_expected_server(tool_name: str) -> Optional[str]:
    \"\"\"Get expected server name for a tool.\"\"\"
    try:
        tool_enum = ToolName(tool_name)
        return TOOL_SERVER_MAPPING[tool_enum].value
    except (ValueError, KeyError):
        return None


def list_all_tools() -> List[str]:
    \"\"\"List all valid tool names.\"\"\"
    return [tool.value for tool in ToolName]


def list_all_servers() -> List[str]:
    \"\"\"List all valid server names.\"\"\"
    return [server.value for server in ServerName]
"""
    
    return python_code

def main():
    """Main entry point."""
    if len(sys.argv) != 2:
        print("Usage: generate_tool_types.py <schema_file.yml>")
        sys.exit(1)
    
    schema_file = Path(sys.argv[1])
    if not schema_file.exists():
        print(f"Schema file not found: {schema_file}")
        sys.exit(1)
    
    # Load schema
    with open(schema_file, 'r') as f:
        schema_data = yaml.safe_load(f)
    
    # Generate Rust types
    rust_output_dir = Path("frontend/src/generated")
    rust_output_dir.mkdir(parents=True, exist_ok=True)
    rust_file = rust_output_dir / "tool_definitions.rs"
    
    with open(rust_file, 'w') as f:
        f.write(generate_rust_enums(schema_data))
    
    print(f"Generated Rust types: {rust_file}")
    
    # Generate Python types
    python_output_dir = Path("backend/zerg/tools/generated")
    python_output_dir.mkdir(parents=True, exist_ok=True)
    python_file = python_output_dir / "tool_definitions.py"
    
    with open(python_file, 'w') as f:
        f.write(generate_python_types(schema_data))
    
    print(f"Generated Python types: {python_file}")

if __name__ == "__main__":
    main()