#!/usr/bin/env python3
"""Generate Python types from tool schema."""

import yaml
import sys
from pathlib import Path
import json

def generate_python_types(schema_data):
    """Generate Python dataclasses from tool schema."""
    
    tool_names = schema_data['components']['schemas']['ToolName']['enum']
    server_names = schema_data['components']['schemas']['ServerName']['enum']
    
    python_code = """# Generated by generate_tool_types.py - DO NOT EDIT MANUALLY

from enum import Enum
from typing import Dict
from typing import List
from typing import Optional


class ToolName(str, Enum):
    \"\"\"Built-in tool names available in the registry.\"\"\"

"""
    
    # Generate ToolName enum
    for tool in tool_names:
        constant_name = tool.upper()
        python_code += f'    {constant_name} = "{tool}"\n'
    
    python_code += """

class ServerName(str, Enum):
    \"\"\"Server/module names for tools.\"\"\"

"""
    
    # Generate ServerName enum
    for server in server_names:
        constant_name = server.upper()
        python_code += f'    {constant_name} = "{server}"\n'
    
    python_code += """

# Tool to server mapping for validation
TOOL_SERVER_MAPPING: Dict[ToolName, ServerName] = {
"""
    
    # Generate mapping
    tool_mappings = schema_data['components']['schemas']['ToolRegistry']['properties']['tool_mappings']['properties']
    for tool_name, server_info in tool_mappings.items():
        tool_const = tool_name.upper()
        server_const = server_info['const'].upper()
        python_code += f"    ToolName.{tool_const}: ServerName.{server_const},\n"
    
    python_code += """}


def validate_tool_registration(tool_name: str, server_name: str) -> bool:
    \"\"\"Validate that tool-server pairing matches schema.\"\"\"
    try:
        tool_enum = ToolName(tool_name)
        server_enum = ServerName(server_name)
        return TOOL_SERVER_MAPPING.get(tool_enum) == server_enum
    except ValueError:
        return False


def get_expected_server(tool_name: str) -> Optional[str]:
    \"\"\"Get expected server name for a tool.\"\"\"
    try:
        tool_enum = ToolName(tool_name)
        return TOOL_SERVER_MAPPING[tool_enum].value
    except (ValueError, KeyError):
        return None


def list_all_tools() -> List[str]:
    \"\"\"List all valid tool names.\"\"\"
    return [tool.value for tool in ToolName]


def list_all_servers() -> List[str]:
    \"\"\"List all valid server names.\"\"\"
    return [server.value for server in ServerName]
"""
    
    return python_code

def main():
    """Main entry point."""
    if len(sys.argv) != 2:
        print("Usage: generate_tool_types.py <schema_file.yml>")
        sys.exit(1)
    
    schema_file = Path(sys.argv[1])
    if not schema_file.exists():
        print(f"Schema file not found: {schema_file}")
        sys.exit(1)
    
    # Load schema
    with open(schema_file, 'r') as f:
        schema_data = yaml.safe_load(f)
    
    # Generate Python types only (Rust frontend removed)
    python_output_dir = Path("apps/zerg/backend/zerg/tools/generated")
    python_output_dir.mkdir(parents=True, exist_ok=True)
    python_file = python_output_dir / "tool_definitions.py"
    
    with open(python_file, 'w') as f:
        f.write(generate_python_types(schema_data))
    
    print(f"Generated Python types: {python_file}")

if __name__ == "__main__":
    main()
