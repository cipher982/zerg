# Docker Compose for Jarvis E2E Testing
# Fully containerized - Playwright runs inside Docker, no host ports exposed
#
# Usage: docker compose -f docker-compose.test.yml run --rm playwright
#
# All services communicate via internal 'test' network using service names:
#   - jarvis-server:8787
#   - jarvis-web:8080

services:
  jarvis-server:
    build:
      context: ../..
      dockerfile: apps/jarvis/apps/server/Dockerfile
    environment:
      JARVIS_SERVER_PORT: ${TEST_SERVER_PORT:-8787}
      NODE_ENV: test
      OPENAI_API_KEY: ${OPENAI_API_KEY:?OPENAI_API_KEY required for e2e tests}
      JARVIS_DEVICE_SECRET: ${JARVIS_DEVICE_SECRET:-test-device-secret}
      # Model configuration - use mini model for faster/cheaper tests
      JARVIS_USE_MINI_MODEL: ${JARVIS_USE_MINI_MODEL:-true}
      JARVIS_REALTIME_MODEL: ${JARVIS_REALTIME_MODEL:-}
      JARVIS_REALTIME_MODEL_MINI: ${JARVIS_REALTIME_MODEL_MINI:-}
      JARVIS_VOICE: ${JARVIS_VOICE:-}
    healthcheck:
      test: ["CMD", "curl", "-sf", "http://localhost:${TEST_SERVER_PORT:-8787}/session"]
      interval: 5s
      timeout: 3s
      retries: 20
      start_period: 15s
    networks:
      - test

  jarvis-web:
    build:
      context: ../..
      dockerfile: apps/jarvis/apps/web/Dockerfile
    depends_on:
      jarvis-server:
        condition: service_healthy
    environment:
      JARVIS_WEB_PORT: ${TEST_WEB_PORT:-8080}
      NODE_ENV: test
      MODELS_CONFIG_PATH: /app/config/models.json
      # Enable bridge mode for e2e tests
      VITE_JARVIS_ENABLE_REALTIME_BRIDGE: "true"
      VITE_JARVIS_DEVICE_SECRET: ${JARVIS_DEVICE_SECRET:-test-device-secret}
      VITE_OPENAI_API_KEY: ${OPENAI_API_KEY}
      # Model configuration - Vite env vars need VITE_ prefix
      VITE_JARVIS_USE_MINI_MODEL: ${JARVIS_USE_MINI_MODEL:-true}
      VITE_JARVIS_REALTIME_MODEL: ${JARVIS_REALTIME_MODEL:-}
      VITE_JARVIS_REALTIME_MODEL_MINI: ${JARVIS_REALTIME_MODEL_MINI:-}
    volumes:
      # Mount config for live updates (same pattern as main docker-compose.yml)
      - ../../config:/app/config:ro
      # Mount source code for hot reload (no rebuild needed for code changes)
      - ../../apps/jarvis/apps/web/src:/app/apps/web/src:ro
      - ../../apps/jarvis/apps/web/lib:/app/apps/web/lib:ro
      - ../../apps/jarvis/packages:/app/packages:ro
    healthcheck:
      test: ["CMD", "curl", "-sf", "http://localhost:${TEST_WEB_PORT:-8080}"]
      interval: 5s
      timeout: 3s
      retries: 20
      start_period: 30s
    networks:
      - test

  playwright:
    build:
      context: ../..
      dockerfile: apps/jarvis/Dockerfile.playwright
    depends_on:
      jarvis-web:
        condition: service_healthy
    environment:
      BASE_URL: http://jarvis-web:${TEST_WEB_PORT:-8080}
      SERVER_URL: http://jarvis-server:${TEST_SERVER_PORT:-8787}
      OPENAI_API_KEY: ${OPENAI_API_KEY:-}
      CI: ${CI:-}
      # Flag to skip WebRTC tests (they don't work in headless Docker)
      SKIP_WEBRTC_TESTS: "true"
      # Model configuration - pass through for test assertions
      JARVIS_USE_MINI_MODEL: ${JARVIS_USE_MINI_MODEL:-true}
      JARVIS_REALTIME_MODEL: ${JARVIS_REALTIME_MODEL:-}
      JARVIS_REALTIME_MODEL_MINI: ${JARVIS_REALTIME_MODEL_MINI:-}
    volumes:
      # Mount test results back to host for inspection
      - ./test-results:/app/test-results
      - ./playwright-report:/app/playwright-report
      # Mount test files for hot reload (edit tests without rebuild)
      - ./tests:/app/tests:ro
    networks:
      - test

networks:
  test:
    driver: bridge
