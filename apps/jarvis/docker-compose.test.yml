# Docker Compose for Jarvis E2E Testing
# Fully containerized - Playwright runs inside Docker, no host ports exposed
#
# Usage: docker compose -f docker-compose.test.yml run --rm playwright
#
# All services communicate via internal 'test' network using service names:
#   - reverse-proxy:80 (entry point for tests)
#   - jarvis-server:8787
#   - jarvis-web:8080
#   - zerg-backend:8000
#   - postgres:5432

services:
  # ---------------------------------------------------------------------------
  # Database (required for zerg-backend)
  # ---------------------------------------------------------------------------
  postgres:
    image: postgres:15-alpine
    environment:
      POSTGRES_USER: test_user
      POSTGRES_PASSWORD: test_password
      POSTGRES_DB: test_db
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U test_user -d test_db"]
      interval: 5s
      timeout: 3s
      retries: 10
    networks:
      - test

  # ---------------------------------------------------------------------------
  # Zerg Backend (provides /api/jarvis/* BFF endpoints)
  # ---------------------------------------------------------------------------
  zerg-backend:
    build:
      context: ../..
      dockerfile: docker/backend.dockerfile
      target: production
    depends_on:
      postgres:
        condition: service_healthy
    environment:
      ENVIRONMENT: test
      DATABASE_URL: postgresql://test_user:test_password@postgres:5432/test_db
      JWT_SECRET: test-jwt-secret-for-e2e
      FERNET_SECRET: HLJRRlT3F0YmZQuS9D-CkKMQM7uKFZNo28OKohhZghU=
      TRIGGER_SIGNING_SECRET: test_trigger_secret
      AUTH_DISABLED: "1"  # Dev mode - auth tests are in backend unit tests
      OPENAI_API_KEY: ${OPENAI_API_KEY:?OPENAI_API_KEY required for e2e tests}
      JARVIS_SERVER_URL: http://jarvis-server:8787
      ALLOWED_CORS_ORIGINS: "*"
      LOG_LEVEL: WARNING
    healthcheck:
      test: ["CMD", "curl", "-sf", "http://localhost:8000/health"]
      interval: 5s
      timeout: 3s
      retries: 20
      start_period: 15s
    networks:
      - test

  # ---------------------------------------------------------------------------
  # Jarvis Server (OpenAI Realtime proxy, MCP tools)
  # ---------------------------------------------------------------------------
  jarvis-server:
    build:
      context: ../..
      dockerfile: apps/jarvis/apps/server/Dockerfile
    environment:
      JARVIS_SERVER_PORT: 8787
      NODE_ENV: test
      OPENAI_API_KEY: ${OPENAI_API_KEY:?OPENAI_API_KEY required for e2e tests}
      JARVIS_DEVICE_SECRET: test-device-secret
      # Model configuration - use mini model for faster/cheaper tests
      JARVIS_USE_MINI_MODEL: ${JARVIS_USE_MINI_MODEL:-true}
      JARVIS_REALTIME_MODEL: ${JARVIS_REALTIME_MODEL:-}
      JARVIS_REALTIME_MODEL_MINI: ${JARVIS_REALTIME_MODEL_MINI:-}
      JARVIS_VOICE: ${JARVIS_VOICE:-}
    healthcheck:
      test: ["CMD", "curl", "-sf", "http://localhost:8787/session"]
      interval: 5s
      timeout: 3s
      retries: 20
      start_period: 15s
    networks:
      - test

  # ---------------------------------------------------------------------------
  # Jarvis Web UI
  # ---------------------------------------------------------------------------
  jarvis-web:
    build:
      context: ../..
      dockerfile: apps/jarvis/apps/web/Dockerfile
    depends_on:
      jarvis-server:
        condition: service_healthy
    environment:
      JARVIS_WEB_PORT: 8080
      NODE_ENV: test
      MODELS_CONFIG_PATH: /app/config/models.json
      # Enable bridge mode for e2e tests
      VITE_JARVIS_ENABLE_REALTIME_BRIDGE: "true"
      VITE_JARVIS_DEVICE_SECRET: test-device-secret
      VITE_OPENAI_API_KEY: ${OPENAI_API_KEY}
      # Model configuration - Vite env vars need VITE_ prefix
      VITE_JARVIS_USE_MINI_MODEL: ${JARVIS_USE_MINI_MODEL:-true}
      VITE_JARVIS_REALTIME_MODEL: ${JARVIS_REALTIME_MODEL:-}
      VITE_JARVIS_REALTIME_MODEL_MINI: ${JARVIS_REALTIME_MODEL_MINI:-}
    volumes:
      # Mount config for live updates
      - ../../config:/app/config:ro
      # Mount source code for hot reload (no rebuild needed for code changes)
      - ../../apps/jarvis/apps/web/src:/app/apps/web/src:ro
      - ../../apps/jarvis/apps/web/lib:/app/apps/web/lib:ro
      - ../../apps/jarvis/packages:/app/packages:ro
    healthcheck:
      test: ["CMD", "curl", "-sf", "http://localhost:8080"]
      interval: 5s
      timeout: 3s
      retries: 20
      start_period: 30s
    networks:
      - test

  # ---------------------------------------------------------------------------
  # Reverse Proxy (routes /api/* to zerg-backend, /chat/* to jarvis-web)
  # ---------------------------------------------------------------------------
  reverse-proxy:
    image: nginx:alpine
    depends_on:
      jarvis-web:
        condition: service_healthy
      zerg-backend:
        condition: service_healthy
    volumes:
      - ./nginx.test.conf:/etc/nginx/conf.d/default.conf:ro
    healthcheck:
      test: ["CMD", "wget", "--no-verbose", "--tries=1", "--spider", "http://127.0.0.1/health"]
      interval: 5s
      timeout: 3s
      retries: 10
    networks:
      - test

  # ---------------------------------------------------------------------------
  # Playwright Test Runner
  # ---------------------------------------------------------------------------
  playwright:
    build:
      context: ../..
      dockerfile: apps/jarvis/Dockerfile.playwright
    depends_on:
      reverse-proxy:
        condition: service_healthy
    environment:
      # Tests go through nginx reverse proxy (same as production)
      BASE_URL: http://reverse-proxy
      SERVER_URL: http://jarvis-server:8787
      ZERG_API_URL: http://zerg-backend:8000
      OPENAI_API_KEY: ${OPENAI_API_KEY:-}
      CI: ${CI:-}
      # Flag to skip WebRTC tests (they don't work in headless Docker)
      SKIP_WEBRTC_TESTS: "true"
      # Model configuration - pass through for test assertions
      JARVIS_USE_MINI_MODEL: ${JARVIS_USE_MINI_MODEL:-true}
      JARVIS_REALTIME_MODEL: ${JARVIS_REALTIME_MODEL:-}
      JARVIS_REALTIME_MODEL_MINI: ${JARVIS_REALTIME_MODEL_MINI:-}
      # Test JWT for auth tests (must match what zerg-backend accepts)
      TEST_JWT_SECRET: test-jwt-secret-for-e2e
    volumes:
      # Mount test results back to host for inspection
      - ./test-results:/app/test-results
      - ./playwright-report:/app/playwright-report
      # Mount test files for hot reload (edit tests without rebuild)
      - ./tests:/app/tests:ro
    networks:
      - test

networks:
  test:
    driver: bridge
