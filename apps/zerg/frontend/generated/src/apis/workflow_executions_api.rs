/*
 * Zerg Agent Platform API
 *
 * Complete REST API specification for the Zerg Agent Platform. This schema is the single source of truth for frontend-backend contracts.
 *
 * The version of the OpenAPI document: 1.0.0
 *
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};

/// struct for passing parameters to the method [`cancel_execution_api_workflow_executions_execution_id_cancel_patch`]
#[derive(Clone, Debug)]
pub struct CancelExecutionApiWorkflowExecutionsExecutionIdCancelPatchParams {
    pub execution_id: i32,
    pub cancel_payload: models::CancelPayload,
    pub session_factory: Option<String>
}

/// struct for passing parameters to the method [`export_execution_data_api_workflow_executions_execution_id_export_get`]
#[derive(Clone, Debug)]
pub struct ExportExecutionDataApiWorkflowExecutionsExecutionIdExportGetParams {
    pub execution_id: i32,
    pub session_factory: Option<String>
}

/// struct for passing parameters to the method [`get_execution_history_api_workflow_executions_history_workflow_id_get`]
#[derive(Clone, Debug)]
pub struct GetExecutionHistoryApiWorkflowExecutionsHistoryWorkflowIdGetParams {
    pub workflow_id: i32,
    pub session_factory: Option<String>
}

/// struct for passing parameters to the method [`get_execution_logs_api_workflow_executions_execution_id_logs_get`]
#[derive(Clone, Debug)]
pub struct GetExecutionLogsApiWorkflowExecutionsExecutionIdLogsGetParams {
    pub execution_id: i32,
    pub session_factory: Option<String>
}

/// struct for passing parameters to the method [`get_execution_status_api_workflow_executions_execution_id_status_get`]
#[derive(Clone, Debug)]
pub struct GetExecutionStatusApiWorkflowExecutionsExecutionIdStatusGetParams {
    pub execution_id: i32,
    pub session_factory: Option<String>
}

/// struct for passing parameters to the method [`get_workflow_schedule_api_workflow_executions_workflow_id_schedule_get`]
#[derive(Clone, Debug)]
pub struct GetWorkflowScheduleApiWorkflowExecutionsWorkflowIdScheduleGetParams {
    pub workflow_id: i32,
    pub session_factory: Option<String>
}

/// struct for passing parameters to the method [`list_scheduled_workflows_api_workflow_executions_scheduled_get`]
#[derive(Clone, Debug)]
pub struct ListScheduledWorkflowsApiWorkflowExecutionsScheduledGetParams {
    pub session_factory: Option<models::serde_json::Value>
}

/// struct for passing parameters to the method [`reserve_workflow_execution_api_workflow_executions_workflow_id_reserve_post`]
#[derive(Clone, Debug)]
pub struct ReserveWorkflowExecutionApiWorkflowExecutionsWorkflowIdReservePostParams {
    pub workflow_id: i32,
    pub session_factory: Option<String>
}

/// struct for passing parameters to the method [`schedule_workflow_api_workflow_executions_workflow_id_schedule_post`]
#[derive(Clone, Debug)]
pub struct ScheduleWorkflowApiWorkflowExecutionsWorkflowIdSchedulePostParams {
    pub workflow_id: i32,
    pub schedule_workflow_payload: models::ScheduleWorkflowPayload,
    pub session_factory: Option<String>
}

/// struct for passing parameters to the method [`start_reserved_execution_api_workflow_executions_executions_execution_id_start_post`]
#[derive(Clone, Debug)]
pub struct StartReservedExecutionApiWorkflowExecutionsExecutionsExecutionIdStartPostParams {
    pub execution_id: i32,
    pub session_factory: Option<String>
}

/// struct for passing parameters to the method [`start_workflow_execution_api_workflow_executions_workflow_id_start_post`]
#[derive(Clone, Debug)]
pub struct StartWorkflowExecutionApiWorkflowExecutionsWorkflowIdStartPostParams {
    pub workflow_id: i32,
    pub session_factory: Option<String>
}

/// struct for passing parameters to the method [`unschedule_workflow_api_workflow_executions_workflow_id_schedule_delete`]
#[derive(Clone, Debug)]
pub struct UnscheduleWorkflowApiWorkflowExecutionsWorkflowIdScheduleDeleteParams {
    pub workflow_id: i32,
    pub session_factory: Option<String>
}


/// struct for typed errors of method [`cancel_execution_api_workflow_executions_execution_id_cancel_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CancelExecutionApiWorkflowExecutionsExecutionIdCancelPatchError {
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`export_execution_data_api_workflow_executions_execution_id_export_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ExportExecutionDataApiWorkflowExecutionsExecutionIdExportGetError {
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_execution_history_api_workflow_executions_history_workflow_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetExecutionHistoryApiWorkflowExecutionsHistoryWorkflowIdGetError {
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_execution_logs_api_workflow_executions_execution_id_logs_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetExecutionLogsApiWorkflowExecutionsExecutionIdLogsGetError {
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_execution_status_api_workflow_executions_execution_id_status_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetExecutionStatusApiWorkflowExecutionsExecutionIdStatusGetError {
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_workflow_schedule_api_workflow_executions_workflow_id_schedule_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetWorkflowScheduleApiWorkflowExecutionsWorkflowIdScheduleGetError {
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_scheduled_workflows_api_workflow_executions_scheduled_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListScheduledWorkflowsApiWorkflowExecutionsScheduledGetError {
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`reserve_workflow_execution_api_workflow_executions_workflow_id_reserve_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ReserveWorkflowExecutionApiWorkflowExecutionsWorkflowIdReservePostError {
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`schedule_workflow_api_workflow_executions_workflow_id_schedule_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ScheduleWorkflowApiWorkflowExecutionsWorkflowIdSchedulePostError {
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`start_reserved_execution_api_workflow_executions_executions_execution_id_start_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StartReservedExecutionApiWorkflowExecutionsExecutionsExecutionIdStartPostError {
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`start_workflow_execution_api_workflow_executions_workflow_id_start_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StartWorkflowExecutionApiWorkflowExecutionsWorkflowIdStartPostError {
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`unschedule_workflow_api_workflow_executions_workflow_id_schedule_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UnscheduleWorkflowApiWorkflowExecutionsWorkflowIdScheduleDeleteError {
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}


/// Mark a running workflow execution as *cancelled*.  The engine cooperatively checks the updated status before starting each new node and exits early. If the execution already finished the endpoint returns 409.
pub async fn cancel_execution_api_workflow_executions_execution_id_cancel_patch(configuration: &configuration::Configuration, params: CancelExecutionApiWorkflowExecutionsExecutionIdCancelPatchParams) -> Result<(), Error<CancelExecutionApiWorkflowExecutionsExecutionIdCancelPatchError>> {

    let uri_str = format!("{}/api/workflow-executions/{execution_id}/cancel", configuration.base_path, execution_id=params.execution_id);
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref param_value) = params.session_factory {
        req_builder = req_builder.query(&[("session_factory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&params.cancel_payload);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<CancelExecutionApiWorkflowExecutionsExecutionIdCancelPatchError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Export the data of a workflow execution.
pub async fn export_execution_data_api_workflow_executions_execution_id_export_get(configuration: &configuration::Configuration, params: ExportExecutionDataApiWorkflowExecutionsExecutionIdExportGetParams) -> Result<serde_json::Value, Error<ExportExecutionDataApiWorkflowExecutionsExecutionIdExportGetError>> {

    let uri_str = format!("{}/api/workflow-executions/{execution_id}/export", configuration.base_path, execution_id=params.execution_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.session_factory {
        req_builder = req_builder.query(&[("session_factory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ExportExecutionDataApiWorkflowExecutionsExecutionIdExportGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the execution history of a workflow.
pub async fn get_execution_history_api_workflow_executions_history_workflow_id_get(configuration: &configuration::Configuration, params: GetExecutionHistoryApiWorkflowExecutionsHistoryWorkflowIdGetParams) -> Result<serde_json::Value, Error<GetExecutionHistoryApiWorkflowExecutionsHistoryWorkflowIdGetError>> {

    let uri_str = format!("{}/api/workflow-executions/history/{workflow_id}", configuration.base_path, workflow_id=params.workflow_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.session_factory {
        req_builder = req_builder.query(&[("session_factory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetExecutionHistoryApiWorkflowExecutionsHistoryWorkflowIdGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the logs of a workflow execution.
pub async fn get_execution_logs_api_workflow_executions_execution_id_logs_get(configuration: &configuration::Configuration, params: GetExecutionLogsApiWorkflowExecutionsExecutionIdLogsGetParams) -> Result<serde_json::Value, Error<GetExecutionLogsApiWorkflowExecutionsExecutionIdLogsGetError>> {

    let uri_str = format!("{}/api/workflow-executions/{execution_id}/logs", configuration.base_path, execution_id=params.execution_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.session_factory {
        req_builder = req_builder.query(&[("session_factory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetExecutionLogsApiWorkflowExecutionsExecutionIdLogsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the status of a workflow execution.
pub async fn get_execution_status_api_workflow_executions_execution_id_status_get(configuration: &configuration::Configuration, params: GetExecutionStatusApiWorkflowExecutionsExecutionIdStatusGetParams) -> Result<serde_json::Value, Error<GetExecutionStatusApiWorkflowExecutionsExecutionIdStatusGetError>> {

    let uri_str = format!("{}/api/workflow-executions/{execution_id}/status", configuration.base_path, execution_id=params.execution_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.session_factory {
        req_builder = req_builder.query(&[("session_factory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetExecutionStatusApiWorkflowExecutionsExecutionIdStatusGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the current schedule for a workflow.
pub async fn get_workflow_schedule_api_workflow_executions_workflow_id_schedule_get(configuration: &configuration::Configuration, params: GetWorkflowScheduleApiWorkflowExecutionsWorkflowIdScheduleGetParams) -> Result<serde_json::Value, Error<GetWorkflowScheduleApiWorkflowExecutionsWorkflowIdScheduleGetError>> {

    let uri_str = format!("{}/api/workflow-executions/{workflow_id}/schedule", configuration.base_path, workflow_id=params.workflow_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.session_factory {
        req_builder = req_builder.query(&[("session_factory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetWorkflowScheduleApiWorkflowExecutionsWorkflowIdScheduleGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// List all scheduled workflows for the current user.
pub async fn list_scheduled_workflows_api_workflow_executions_scheduled_get(configuration: &configuration::Configuration, params: ListScheduledWorkflowsApiWorkflowExecutionsScheduledGetParams) -> Result<serde_json::Value, Error<ListScheduledWorkflowsApiWorkflowExecutionsScheduledGetError>> {

    let uri_str = format!("{}/api/workflow-executions/scheduled", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.session_factory {
        req_builder = req_builder.query(&[("session_factory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ListScheduledWorkflowsApiWorkflowExecutionsScheduledGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Reserve an execution ID for a workflow without starting execution. This allows the frontend to subscribe to WebSocket messages before execution starts.
pub async fn reserve_workflow_execution_api_workflow_executions_workflow_id_reserve_post(configuration: &configuration::Configuration, params: ReserveWorkflowExecutionApiWorkflowExecutionsWorkflowIdReservePostParams) -> Result<serde_json::Value, Error<ReserveWorkflowExecutionApiWorkflowExecutionsWorkflowIdReservePostError>> {

    let uri_str = format!("{}/api/workflow-executions/{workflow_id}/reserve", configuration.base_path, workflow_id=params.workflow_id);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = params.session_factory {
        req_builder = req_builder.query(&[("session_factory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ReserveWorkflowExecutionApiWorkflowExecutionsWorkflowIdReservePostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Schedule a workflow to run on a cron schedule.
pub async fn schedule_workflow_api_workflow_executions_workflow_id_schedule_post(configuration: &configuration::Configuration, params: ScheduleWorkflowApiWorkflowExecutionsWorkflowIdSchedulePostParams) -> Result<serde_json::Value, Error<ScheduleWorkflowApiWorkflowExecutionsWorkflowIdSchedulePostError>> {

    let uri_str = format!("{}/api/workflow-executions/{workflow_id}/schedule", configuration.base_path, workflow_id=params.workflow_id);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = params.session_factory {
        req_builder = req_builder.query(&[("session_factory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&params.schedule_workflow_payload);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ScheduleWorkflowApiWorkflowExecutionsWorkflowIdSchedulePostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Start a previously reserved execution.
pub async fn start_reserved_execution_api_workflow_executions_executions_execution_id_start_post(configuration: &configuration::Configuration, params: StartReservedExecutionApiWorkflowExecutionsExecutionsExecutionIdStartPostParams) -> Result<serde_json::Value, Error<StartReservedExecutionApiWorkflowExecutionsExecutionsExecutionIdStartPostError>> {

    let uri_str = format!("{}/api/workflow-executions/executions/{execution_id}/start", configuration.base_path, execution_id=params.execution_id);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = params.session_factory {
        req_builder = req_builder.query(&[("session_factory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StartReservedExecutionApiWorkflowExecutionsExecutionsExecutionIdStartPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Start a new execution of a workflow using LangGraph engine. Uses the original synchronous approach.
pub async fn start_workflow_execution_api_workflow_executions_workflow_id_start_post(configuration: &configuration::Configuration, params: StartWorkflowExecutionApiWorkflowExecutionsWorkflowIdStartPostParams) -> Result<serde_json::Value, Error<StartWorkflowExecutionApiWorkflowExecutionsWorkflowIdStartPostError>> {

    let uri_str = format!("{}/api/workflow-executions/{workflow_id}/start", configuration.base_path, workflow_id=params.workflow_id);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = params.session_factory {
        req_builder = req_builder.query(&[("session_factory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StartWorkflowExecutionApiWorkflowExecutionsWorkflowIdStartPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Remove the schedule for a workflow.
pub async fn unschedule_workflow_api_workflow_executions_workflow_id_schedule_delete(configuration: &configuration::Configuration, params: UnscheduleWorkflowApiWorkflowExecutionsWorkflowIdScheduleDeleteParams) -> Result<serde_json::Value, Error<UnscheduleWorkflowApiWorkflowExecutionsWorkflowIdScheduleDeleteError>> {

    let uri_str = format!("{}/api/workflow-executions/{workflow_id}/schedule", configuration.base_path, workflow_id=params.workflow_id);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref param_value) = params.session_factory {
        req_builder = req_builder.query(&[("session_factory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UnscheduleWorkflowApiWorkflowExecutionsWorkflowIdScheduleDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

