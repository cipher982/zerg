/*
 * Zerg Agent Platform API
 *
 * Complete REST API specification for the Zerg Agent Platform. This schema is the single source of truth for frontend-backend contracts.
 *
 * The version of the OpenAPI document: 1.0.0
 *
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};

/// struct for passing parameters to the method [`create_trigger_api_triggers_post`]
#[derive(Clone, Debug)]
pub struct CreateTriggerApiTriggersPostParams {
    pub trigger_create: models::TriggerCreate,
    pub session_factory: Option<models::serde_json::Value>
}

/// struct for passing parameters to the method [`delete_trigger_api_triggers_trigger_id_delete`]
#[derive(Clone, Debug)]
pub struct DeleteTriggerApiTriggersTriggerIdDeleteParams {
    pub trigger_id: i32,
    pub session_factory: Option<String>
}

/// struct for passing parameters to the method [`fire_trigger_event_api_triggers_trigger_id_events_post`]
#[derive(Clone, Debug)]
pub struct FireTriggerEventApiTriggersTriggerIdEventsPostParams {
    pub trigger_id: i32,
    pub x_zerg_timestamp: String,
    pub x_zerg_signature: String,
    pub session_factory: Option<String>,
    pub body: Option<serde_json::Value>
}

/// struct for passing parameters to the method [`list_triggers_api_triggers_get`]
#[derive(Clone, Debug)]
pub struct ListTriggersApiTriggersGetParams {
    /// Filter triggers by agent ID
    pub agent_id: Option<i32>,
    pub session_factory: Option<models::serde_json::Value>
}


/// struct for typed errors of method [`create_trigger_api_triggers_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateTriggerApiTriggersPostError {
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_trigger_api_triggers_trigger_id_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteTriggerApiTriggersTriggerIdDeleteError {
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fire_trigger_event_api_triggers_trigger_id_events_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FireTriggerEventApiTriggersTriggerIdEventsPostError {
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_triggers_api_triggers_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListTriggersApiTriggersGetError {
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}


/// Create a new trigger for an agent.  If the trigger is of type *email* and the provider is **gmail** we kick off an asynchronous helper that ensures a Gmail *watch* is registered.  The call is awaited so tests (which run inside the same event-loop) can verify the side-effects synchronously without sprinkling ``asyncio.sleep`` hacks.
pub async fn create_trigger_api_triggers_post(configuration: &configuration::Configuration, params: CreateTriggerApiTriggersPostParams) -> Result<models::Trigger, Error<CreateTriggerApiTriggersPostError>> {

    let uri_str = format!("{}/api/triggers/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = params.session_factory {
        req_builder = req_builder.query(&[("session_factory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&params.trigger_create);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Trigger`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Trigger`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateTriggerApiTriggersPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Delete a trigger.  Special handling for *email* provider **gmail**:  • Attempts to call Gmail *stop* endpoint so push notifications are   turned off immediately on user’s mailbox.  The call is best effort –   network/auth failures are logged but do not abort the deletion.
pub async fn delete_trigger_api_triggers_trigger_id_delete(configuration: &configuration::Configuration, params: DeleteTriggerApiTriggersTriggerIdDeleteParams) -> Result<(), Error<DeleteTriggerApiTriggersTriggerIdDeleteError>> {

    let uri_str = format!("{}/api/triggers/{trigger_id}", configuration.base_path, trigger_id=params.trigger_id);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref param_value) = params.session_factory {
        req_builder = req_builder.query(&[("session_factory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteTriggerApiTriggersTriggerIdDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Webhook endpoint that fires a trigger event.  Security: the caller must sign the request body using HMAC-SHA256.  Signature string to hash:     \"{timestamp}.{raw_body}\"  where *timestamp* is the same value sent in `X-Zerg-Timestamp` header and *raw_body* is the exact JSON body (no whitespace changes).  The hex-encoded digest is provided via `X-Zerg-Signature` header.
pub async fn fire_trigger_event_api_triggers_trigger_id_events_post(configuration: &configuration::Configuration, params: FireTriggerEventApiTriggersTriggerIdEventsPostParams) -> Result<serde_json::Value, Error<FireTriggerEventApiTriggersTriggerIdEventsPostError>> {

    let uri_str = format!("{}/api/triggers/{trigger_id}/events", configuration.base_path, trigger_id=params.trigger_id);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = params.session_factory {
        req_builder = req_builder.query(&[("session_factory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-Zerg-Timestamp", params.x_zerg_timestamp.to_string());
    req_builder = req_builder.header("X-Zerg-Signature", params.x_zerg_signature.to_string());
    req_builder = req_builder.json(&params.body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<FireTriggerEventApiTriggersTriggerIdEventsPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// List all triggers, optionally filtered by agent_id.
pub async fn list_triggers_api_triggers_get(configuration: &configuration::Configuration, params: ListTriggersApiTriggersGetParams) -> Result<Vec<models::Trigger>, Error<ListTriggersApiTriggersGetError>> {

    let uri_str = format!("{}/api/triggers/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.agent_id {
        req_builder = req_builder.query(&[("agent_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.session_factory {
        req_builder = req_builder.query(&[("session_factory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::Trigger&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::Trigger&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ListTriggersApiTriggersGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

