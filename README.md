
# Agent Platform Frontend

A Rust + WebAssembly powered frontend for creating interactive conversation flows with AI responses. Users can add “nodes” (messages), which the AI responds to, creating a visual conversation tree.

## Table of Contents
1. [Overview](#overview)  
2. [Key Features](#key-features)  
3. [Directory Structure](#directory-structure)  
4. [Dependencies](#dependencies)  
5. [Building & Running](#building--running)  
6. [How It Works](#how-it-works)  
7. [Extending the Project](#extending-the-project)

---

## Overview
This frontend application provides a canvas-based UI for interacting with an AI backend. Written in Rust and compiled to WebAssembly, it uses the following libraries:
• wasm-bindgen, web-sys, and js-sys for DOM and browser APIs.  
• serde and serde_json for data serialization.  
• A user interface allowing panning, zooming, auto-fitting, and manually moving “nodes.”

Local data (nodes, viewport transforms, selected AI model) is stored in localStorage to persist sessions. A WebSocket is used to listen for AI responses, which appear as new nodes attached to the user’s last input.

---

## Key Features
• Create and manage an interactive conversation tree of user inputs (blue nodes) and AI responses (purple nodes).  
• Pan and zoom the canvas, or rely on auto-fitting.  
• Choice of AI models from a dropdown.  
• Automatic save/loading of the entire graph in localStorage.  
• Automatic generation of a canvas-based favicon.

---

## Directory Structure

Below is a simplified overview of the top-level files:

• Cargo.toml – Rust crate metadata, specifying dependencies for wasm-bindgen, web-sys, etc.  
• build.sh – Convenience script that builds the WASM binary and serves the finished site locally.  
• src/ – Primary Rust source code:  

  └── canvas/  
      • mod.rs        – Module definition for canvas sub-crate.  
      • renderer.rs   – Drawing logic for nodes and connections.  
      • shapes.rs     – Helper functions for shapes like bubbles, rounded rectangles, and arrows.  

  • favicon.rs       – Generates a dynamic favicon by drawing onto a small canvas.  
  • lib.rs           – Entry point that configures the runtime, sets up UI, and initializes the app.  
  • models.rs        – Data models (Node, NodeType) with derived serialization.  
  • network.rs       – Manages WebSocket and HTTP requests to the AI backend.  
  • state.rs         – Global AppState tracking all data (nodes, viewport, selected model, etc.).  
  • storage.rs       – Handles loading/saving state from localStorage.  
  • ui.rs            – Builds HTML elements, event handlers, and user interaction logic.

• target/ – Default Rust build directory with compiled artifacts and the .wasm generated by wasm-pack.  
• www/ – Output web folder used by build.sh. Contains index.html, the .wasm, and a small JS loader.

---

## Dependencies

• Rust (Edition 2021).  
• wasm-bindgen (0.2.87) – Required to interface between Rust code and JavaScript.  
• wasm-pack – To package the project for web deployment.  
• web-sys, js-sys – Wrappers around DOM and JavaScript functionality.  
• Python – Optional for running "python -m http.server" to serve the site (used in build.sh).  
• The backend is assumed to run on localhost:8001 for the WebSocket and HTTP routes.

---

## Building & Running

1. Ensure you have Rust and wasm-pack installed:  
   » cargo install wasm-pack

2. Clone the repository, then run:  
   » chmod +x build.sh  
   » ./build.sh  

3. The build script will:  
   • Compile the Rust code to WASM via “wasm-pack build --target web --out-dir www”.  
   • Move the generated JavaScript file in “www/agent_platform_frontend.js” to “www/index.js” for simplicity.  
   • Start a Python HTTP server on port 8002.

4. Open a browser to:  
   http://localhost:8002/  

5. Interact with the UI:  
   • Enter text in the input field, then click “Send to AI.” A blue node appears.  
   • The AI’s response arrives over the WebSocket and is displayed as a purple node attached under the user input.  
   • Drag nodes or the background to reposition. Enable or disable auto-fit with the toggle.  
   • Switch between available AI models in the dropdown.

---

## How It Works

1. The “start()” function in lib.rs runs automatically when the WASM module loads in the browser.  
2. The interface is created (ui.rs), wires up event handlers (click, keypress, drag, wheel zoom).  
3. The global state (state.rs) tracks all nodes, their positions, the viewport, etc.  
4. network.rs sets up a WebSocket to “ws://localhost:8001/ws” and an HTTP POST route “/api/process-text.”  
5. storage.rs loads/saves the node graph in localStorage, so reloading the page preserves your conversation.  
6. The canvas is rendered by the functions in canvas/renderer.rs and canvas/shapes.rs.

---

## Extending the Project

• Want a new node type or shape? Add an enum variant to NodeType in models.rs, then draw it in shapes.rs.  
• Adjust auto-fitting, zoom logic, or viewport restrictions in state.rs.  
• Replace or expand the AI backend URL in network.rs if your server runs elsewhere or supports more endpoints.  
• Customize the UI by editing ui.rs to create more DOM elements, style them, or add additional controls.

---

Enjoy hacking on your Rust + WebAssembly conversation flow graph!